#!/bin/bash
# ==============================================================================
# TABLE
# A tool to pipe unformatted table-like data in and get a formatted table out.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# ==============================================================================

# default variables  
INPUT_COLUMN_SEPARATOR=" " 
INPUT_HAS_HEADER=0
PRINT_TABLE_BORDERS=0
declare -a FILE_CONTENT
declare -a COLUMN_WIDTHS

function debug () {
	return # comment to see output 
	echo "$1"
}

function show_help () {
	echo -e "Auto-formats table-like data read from standard-in."
	echo -e "\nUsage: `basename $0` [-s <FS>] [-y] [-h]\n"
	echo -e "\t-s <FS>\t\tColumn separator in input data (default: '$INPUT_COLUMN_SEPARATOR')."
	echo -e "\t-y\t\tData has header."
	echo -e "\t-t\t\tPrint table borders in output."
	echo -e "\t-h\t\tPrint this help."
	echo -e "\nExample: cat mytabledata.txt | table -s \";\" -y\n"
	exit 1
}

# read command line 
while getopts "s:yth" opt; do
    case "$opt" in
    s)
        INPUT_COLUMN_SEPARATOR=$OPTARG
        ;;
	y)  INPUT_HAS_HEADER=1
		;;
	t)  PRINT_TABLE_BORDERS=1
		;;
	h)  show_help; exit 0
		;;
	*)	echo "Illegal argument"; exit 1 
		;;
	esac
done

if [ $PRINT_TABLE_BORDERS == 1 ]
then
	OUT_COLUMN_SEPARATOR="║"
fi

# read from stdin to array 
it=0
while read line
do
	if [ ! -z "$line" ]
	then 
		FILE_CONTENT[$it]="$line"
		it=$(( $it + 1 ))
	fi
done < /dev/stdin

# get number of columns 
for it in $( seq 0 $(( ${#FILE_CONTENT[@]} - 1 )) )
do
	row_columns=$(IFS=$INPUT_COLUMN_SEPARATOR; set -- ${FILE_CONTENT[$it]}; echo $#)
	if [ -v $columns ] || [ $row_columns -ge $columns ]
	then
		columns=$row_columns
	fi
done  
debug "col_tot=$columns"

# get columns widths
for it in $( seq 0 $(( ${#FILE_CONTENT[@]} - 1 )) )
do
	if [ "$INPUT_COLUMN_SEPARATOR" == " " ]; then
		row_content=( ${FILE_CONTENT[$it]} )
	else 
		line=$( echo ${FILE_CONTENT[$it]} | tr " " "_" | tr "$INPUT_COLUMN_SEPARATOR" " " )
		row_content=( $line )
	fi 
	for yt in $( seq 0 $(( $columns - 1 )) )
	do
		col_wid=${#row_content[$yt]}
		if [ -v ${COLUMN_WIDTHS[$yt]} ] || [ $col_wid -gt ${COLUMN_WIDTHS[$yt]} ]
		then 
			COLUMN_WIDTHS[$yt]=$col_wid 
		fi 
	done 
done

debug "col_widths=${COLUMN_WIDTHS[@]}"

# generate format string 
format_string="$lead_string$OUT_COLUMN_SEPARATOR${lead_string}"
lead_string=
if [ $PRINT_TABLE_BORDERS == 1 ]; then lead_string=" "; fi
for it in $( seq 0 $(( ${#COLUMN_WIDTHS[@]} - 1 )) )
do
	format_string="${format_string}${lead_string}%-$(( ${COLUMN_WIDTHS[$it]} + 1 ))s$OUT_COLUMN_SEPARATOR"
done
format_string="${format_string}\n"

debug "format_string=$format_string"
debug "header_len=$header_len"
debug "table_sep='$OUT_COLUMN_SEPARATOR'"
debug "len_tsep=$LEN_OUT_COLUMN_SEPARATOR"

function print_rule () {
	if [ $PRINT_TABLE_BORDERS == 1 ]
	then
		rule="$1"
		for it in $( seq 0 $(( ${#COLUMN_WIDTHS[@]} - 1 )) )
		do
			rule=${rule}$( printf '═%.0s' $(eval echo {1..$(( ${COLUMN_WIDTHS[$it]} + 2 ))}) )
			if [ $it != $(( ${#COLUMN_WIDTHS[@]} - 1 )) ]; then rule="${rule}$3"; fi
		done
		echo -e "$rule$2"
	fi
}

# format and output lines 
print_rule "\n╔" "╗" "╦" 
for it in $( seq 0 $(( ${#FILE_CONTENT[@]} - 1 )) )
do
	if [ "$INPUT_COLUMN_SEPARATOR" == " " ]; then
		row_content=( ${FILE_CONTENT[$it]} )
	else 
		line=$( echo ${FILE_CONTENT[$it]} | tr " " "_" | tr "$INPUT_COLUMN_SEPARATOR" " " )
		row_content=( $line )
	fi 
	printf "$format_string" ${row_content[@]}
	if [ $INPUT_HAS_HEADER == 1 ] && [ $it == 0 ]
	then 
		print_rule "╠" "╣" "╬"
	fi 
done 
print_rule "╚" "╝\n" "╩"
