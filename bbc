#!/bin/bash
# ==============================================================================
# BASTI'S BASH COMMONS
# Commonly used bash methods.
# 
# Best way to include is to add the script to your path and include with
# if [ ! -v $( command -v "bbc" ) ]; then source bbc; else exit; fi
#
# Licensed under the Apache License, Version 2.0 (the "License");
# ==============================================================================

# ==============================================================================
# ENVIRONMENT UTILITIES
# ==============================================================================

function bbc_is_cygwin () {
	init_help_output "$FUNCNAME" "Returs 1 if this script runs in a cygwin \
environment and 0 if not." $@ || return $?

	[ -z "$( uname -a | grep -i "cygwin" )"/ ] && echo 0 || echo 1 
    
}

function bbc_get_bash_version () {
	init_help_output "$FUNCNAME" "Returns the bash version as separated string \
to check for compatibility." $@ || return $?

	bash --version | head -n1 | sed -r -e "s/^[^0-9]+([0-9\\.]+).*/\1/g" |\
	tr "." " "
}

function bbc_exe () {
	init_help_output "$FUNCNAME" "Tests if a command does exist and, if yes, \
runs it. This comes in handy if you are unsure whether a tool exists.\
[1] Command to be executed." $@ || return $?
	
	[ ! -v $( command -v $1 ) ] && { eval $@; return 0; } || return 1
	
}

# ==============================================================================
# PRODUCTIVITY UTILITIES
# ==============================================================================

function bbc_calc () {
    	init_help_output "$FUNCNAME" "A convenience wrapper for bc. [1] .. [n] \
The arithmetical problem you want to solve." \
$@ || return $?

    [ $# -le 0 ] && { echo "No bc-compatible calculation provided."; return 1; }
    calculate=$( sed -e "s/,/./g" <<< "$@" )
    echo "scale=4; ${calculate}" | bc
}

function bbc_days_between () {
	init_help_output "$FUNCNAME" "Calculates the time between two given dates \
in the form YYYY-MM-DD and with the second date included in the calculation.\
[1] First date. [2] Second date (optional, default: today)." \
$@ || return $?

    [ $# -le 0 ] && { echo "You must set at least one date."; return 1; }
    
    ep1=$( date --date "$1" +%s )
    [ -v $2 ] && ep2=$( date +%s ) || ep2=$( date --date "$2" +%s )
    diffEp=$(( $ep2 - $ep1 ))
    bbc_calc "$diffEp / 60 / 60 / 24"     
    
}

function bbc_zip () {
	init_help_output "$FUNCNAME" "Straight-forward zipping with mandatory \
AES-encryption and removal of source file/folder respectively source zip-file.\
[1] Direction, either (p)ack or (u)npack. [2] Folder/file." \
$@ || return $?

    [ -z $( command -v 7z ) ] && { echo "No 7zip installed."; return 1; }
    direction=p 
    [ "$1" != "p" ] && [ "$1" != "u" ] && { echo "Bad direction."; return 1; } \
    || direction="$1" 
    [ ! -e "$2" ] && { echo "File/folder not readable."; return 1; } 

    if [ "$direction" == "p" ]; then
        7za a -p -tzip -mem=AES256 "$( basename "$2" ).zip" "$2"
        [ $? == 0 ] && rm -rf "$2"
    else
        7za x "$2"
        [ $? == 0 ] && rm -rf "$2"
    fi
    
}

function bbc_zip_subfolders() {
    init_help_output "$FUNCNAME" "Zips the content of all immediate sub-\
directories to ZIP-files with the same name." $@ || return $?
       
    find -maxdepth 1 -type d ! -name "." | while read dir;
    do
        bname=$( basename $dir )
        echo "=== ZIPPING $bname"
        cd $dir
        zip -r ../${bname}.zip *
        cd ..
    done
}

function bbc_wd () {
	init_help_output "$FUNCNAME" "An extension of the system's default cd \
command with pattern-based searching of candidates before changing to the \
candidate folder that has been found. wd means 'warp directory'.[1] Directory \
pattern." $@ || return $?

	MAX_DEPTH=3 # How deep should wd look in the folder tree for matches? 
	MAX_HITS_BEFORE_BREAK=5 # After how many hits should wd stop searching? 
	
	# important: use builtin cd in scenarios where cd is aliased to bbc_wd !!
	
	# on 'wd' without any options, don't do anything (in contrast to 'cd' )
	if [ $# -le 0 ] || [ -v "$1" ]; then return; fi 
	# keep 'cd -' function, but without output
	if [ "$1" == "-" ]; then builtin cd - &> /dev/null; return; fi 
	# keep 'cd ..' function
	if [ "$1" == ".." ]; then builtin cd ..; return; fi  
	# 'cd ...' function
	if [ "$1" == "..." ]; then builtin cd ..; builtin cd ..; return; fi
	# 'cd <folder>' if folder exists (basic cd behaviour) 
	if [ -e "$1" ] && [ -d "$1" ]; then builtin cd "$1"; return; fi 
	# on absolute paths just do a normal cd 
	if [[ "$1" =~ ^/.* ]]; then builtin cd "$1"; return; fi
	# pattern-based search and changing of dirs
	no_hits=0
	first_hit=
	pattern=$( echo "*${1}*" | sed -r -e "s/[\/]+/\//g" -e "s/\//*\/*/g" )
	# core command: all dirs, no hidden dirs 
	command="find -maxdepth $MAX_DEPTH -type d \( -iwholename \"$pattern\" ! \
	-iwholename \"*\/.*\" \) -prune 2> /dev/null"	
	#echo "--- warping to: '${pattern}' with '${command}'"
	for hit in $( eval $command ) 
	do
		if [ $no_hits == 0 ]; then first_hit=$hit; fi 
		no_hits=$(( $no_hits + 1 ))
		echo $hit
		if [ $no_hits == $MAX_HITS_BEFORE_BREAK ]; then 
			echo -e "...\n-bash: wd: $1: Too many potential hits"; break 
		fi 
	done
	if [ $no_hits == 0 ]; then 
		echo "-bash: wd: $1: No such file or directory"; return
	elif [ $no_hits -ge 2 ]; then 
		return
	else 
		builtin cd $first_hit
	fi 
}

function bbc_generate_rsa_keypair () {
    init_help_output "$FUNCNAME" "Generates an RSA public and private key pair \
in the users home folder." $@ || return $?
    
    if [ $( bbc_is_cygwin ) == 1 ]; then
		mkdir -p ${USERPROFILE}/.ssh
		targetdir_arg="-f $( cygpath -u ${USERPROFILE}/.ssh )/id_rsa"
	fi
    ssh-keygen -q -t rsa -b 4096 ${targetdir_arg} -N ''
}

function bbc_run_psql () {
	init_help_output "$FUNCNAME" "Runs a given postgresql command through the \
psql command line. ATTENTION: This method assumes that \$PG_PASS \$PG_USSER \
and \$PG_DB are set somewhere in your script.[1] PostgreSQL Query with \
escaped quotation marks." $@ || return $?

	export PGPASSWORD=$PG_PASS
	psql -h localhost -t -F " " -A -c "$1" $PG_DB $PG_USER
}

function bbc_archive () {
	init_help_output "$FUNCNAME" "Packs the given folder to a zip archive \
and removes the source folder on successful packaging. Optionally you can set \
a 'BBC_ARCHIVE_FOLDER' pointing to your desired archive folder.[1] Source \
folder to be packed." $@ || return $?

    target_folder="."
    [ ! -z $BBC_ARCHIVE_FOLDER ] && target_folder=$BBC_ARCHIVE_FOLDER
    target_folder=$( readlink -f $target_folder )
    [ -z "$1" ] && { echo "No folder provided."; return 1; }
    datetime=$( bbc_get_datetime )

    fulldir=$( readlink -f "$1" )
    [ ! -d "$fulldir" ] && { echo "Given path is not a directory"; return 1; }
    basename=$( basename $fulldir )
    trgfile=${datetime}_${basename}.zip

    echo -e "You want to pack '$fulldir' to '${target_folder}/$trgfile' and remove source folder."
    yes=$( bbc_yesno "Are you sure?" )
    [ $yes != 1 ] && { echo; return 0; }
    
    cd $fulldir
    zip -9r ${trgfile} *
    mv ${trgfile} ${target_folder}
    cd -
    if [ -e ${trgfile} ] && [ $( tar -xOf ${trgfile} > /dev/null; echo $? ) == 0 ]
    then
      echo -e "\nPacking successful. Will remove source folder."
      rm -rf $fulldir
    else
      echo -e "\nError while packing. Source folder not deleted."
      return 1
    fi
    echo -e "Done."
    return 0
}

# ==============================================================================
# GIT UTILITIES
# ==============================================================================

function bbc_git_repoinit () {
    init_help_output "$FUNCNAME" "Quick fix to setup a newly cloned github \
repository with the desired username and email and apply some fixes.[1] \
Your github username.[2] Your github e-mail address." $@ || return $?

    [ -z "$1" ] && { echo "No username provided."; return 1; } 
    [ -z "$2" ] && { echo "No user e-mail provided."; return 1; } 

    git config user.name "$1"
	git config user.email "$2"
	# Fix https origin 
	https_link=$( cat .git/config | grep -A3 "\[remote \"origin\"\]" |\
	grep https: | awk '{print $3}')
	if [ ! -v $https_link ]
	then
		echo "Fixing https origin $https_link"
		sed -i -e "s/https\:\/\/github\.com\//git@github.com:/g" .git/config
		echo "Maybe you need to fix: http://stackoverflow.com/questions/\
2643502/git-permission-denied-publickey"
	fi
	echo "Running 'git pull -r' now. If you experience login problems, you \
might also need to add your public rsa key to github."
    git pull -r
    
}

function bbc_git_is_repo () {
    init_help_output "$FUNCNAME" "Returns 1 if you're currently inside a git \
repository folder." $@ || return $?

    git rev-parse 2> /dev/null; [ $? == 0 ] && echo 1
}

function bbc_git_author_contributions () {
    init_help_output "$FUNCNAME" "Checks for line/code changes of the given \
author and outputs some summarized statistics.[1] Username (can be a pattern).\
[2] Since-date, e.g., 01.12.2015.[3] File pattern (optional, all if \
ommitted)." $@ || return $?

    [ "$( bbc_git_is_repo )" != "1" ] && { echo "You're not inside a git repo \
directory."; return 1; }
    [ -z "$1" ] && { echo "Author name must be set."; return 1; }
    since="1.weeks"
    [ ! -z "$2" ] && since="$2"
    [ -z "$3" ] && pattern="" || pattern="-- $3"    
    
    git_base="git --no-pager log --no-merges --since=${since} --all \
    --not origin/rel12v0 --author=$1 "
    eval $git_base --oneline $pattern
    eval $git_base --numstat --pretty="" "$pattern" | awk \
    'BEGIN { ins=0; del=0; tot=0; files=0; } \
    { files+=1; ins+=$1; del+=$2; tot=tot+$1-$2; } \
     END {print "== LOC_INSERTED: "ins" LOC_DELETED: "del" LOC_SUM: "tot" FILES: "files }'
}

# ==============================================================================
# INTERACTIVITY UTILITIES
# ==============================================================================

function bbc_clear () {
	init_help_output "$FUNCNAME" "Clears the screen for real and removes any\
preceeding content." $@ || return $?

	printf "\033c"
}

function bbc_askpass () {
	init_help_output "$FUNCNAME" "Asks the user for a password.[1] Optional \
alternate question, e.g. \"Enter your google.com password\"." $@ || return $?

	question="Enter password"
	if [ $# -ge 1 ]; then question=$1; fi
	read -s -p "$question: " bbc_password
	echo ""
}

function bbc_yesno () {
	init_help_output "$FUNCNAME" "Asks the user a yes/no question and returns \
1 if 'yes' and 0 if 'no'.[1] The question to ask." $@ || return $?

	read -p "$1 (y/n)" -n 1 -r
	echo "" # (optional) move to a new line
	if [[ $REPLY =~ ^[Yy]$ ]]
	then
		echo 1
	else
		echo 0
	fi
}

# ==============================================================================
# DATE/TIME UTILITIES 
# ==============================================================================

function bbc_get_datetime () {
	init_help_output "$FUNCNAME" "Returns a file-safe datetime timestamp to \
be used in files." $@ || return $?
	
	date "+%Y%m%d-%H%M%S"
}

function bbc_epoch () {
	init_help_output "$FUNCNAME" "Returns the current epoch timestamp." $@ || \
return $?
	
	date "+%s"
}

# ==============================================================================
# I/O UTILITIES 
# ==============================================================================

function bbc_find_leaf_dirs () {
	init_help_output "$FUNCNAME" "Returns all folder names that don't have any \
subfolders of their own.[1] Path to directory." $@ || return $?

	[ -z "${1}" ] || [ ! -e "${1}" ] && { echo "No or unknown folder."; return;}
	find "${1}" -type d -exec sh -c '(ls -p "{}"|grep />/dev/null)||echo "{}"' \;
}

function bbc_whereami () {
	init_help_output "$FUNCNAME" "Returns the location of the current script.\
[1] If '-d' then return parent dirname only."\
	$@ || return $?

	location=$( readlink -f $( dirname $0 ))
	if [ "$1" == "-d" ]; then
		echo ${location}
	else
		echo ${location}/$( basename $0 )
	fi
}

function bbc_get_filename () {
	init_help_output "$FUNCNAME" "Returns filename without path and suffix \
from given filepath.[1] Path to file." $@ || return $?
	
	filename=$(basename "$1")
	echo ${filename%.*}
}

function bbc_get_filesuffix () {
	init_help_output "$FUNCNAME" "Returns the file suffix without path and \
filename from given filepath.[1] Path to file." $@ || return $?
	
	filename=$(basename "$1")
	echo ${filename##*.}
}

# ==============================================================================
# STRING UTILITIES 
# ==============================================================================

function bbc_split_on_pattern () {
	init_help_output "$FUNCNAME" "Splits a file on a given regex pattern into \
multiple files.[1] Input file.[2] Regular expression to split file at." \
$@ || return $?
	
	base=$( bbc_get_filename $1 )
	suff=$( bbc_get_filesuffix $1 )
	awk -v pat="$2" -v base=$base -v suff=$suff '$0 ~ pat { i++ }{ \
	print > base"."sprintf("%05d", i)"."suff }' ${1}
}

function bbc_justify_text () {
	init_help_output "$FUNCNAME" "Folds the given text to either at a fixed \
number of columns or, if obtainable, the width of the console or at a fixed \
with of 70.[1] Input text.[2] Optional line width." \
	$@ || return $?

	columns=$2
	if [ -v $columns ]; then columns=$( bbc_exe "tput cols" ); fi
	if [ -v $columns ]; then columns=70; fi
	echo -e "$1" | fold -s -w $columns 
}

function bbc_remove_duplicate_empty_lines () {
	init_help_output "$FUNCNAME" "Removes duplicate empty lines read from \
standard-in." $@ || return $?
	
	sed 'N;/^\n$/d;P;D' < /dev/stdin 
}

function bbc_urlencode () {
	init_help_output "$FUNCNAME" "URL-enodes the given string.[1] The \
string to be encoded." $@ || return $?

	echo "$1" | sed -e "s/!/%21/g" -e "s/\"/%22/g" -e "s/#/%23/g" \
	-e "s/\\$/%24/g" -e "s/&/%26/g" -e "s/'/%27/g" -e "s/(/%28/g" \
	-e "s/)/%29/g" -e "s/*/%2A/g" -e "s/+/%2B/g" -e "s/,/%2C/g" \
	-e "s/\//%2F/g" -e "s/:/%3A/g" -e "s/;/%3B/g" -e "s/=/%3D/g" \
	-e "s/?/%3F/g" -e "s/@/%40/g" -e "s/\[/%5B/g" -e "s/\]/%5D/g" \
	-e "s/ /%20/g" 
}

function bbc_print_xml () {
	init_help_output "$FUNCNAME" "Pretty-prints an XML string to the command \
line.[1] XML-file." $@ || return $?
	
	bbc_exe tput setaf 1
	echo
	xmllint --format $1
	echo
	bbc_exe tput sgr 0
}

# ==============================================================================
# INTERNAL FUNCTIONS
# ==============================================================================

function init_help_output () {
	function_name="$1"; shift
	function_help="$1"; shift
	fg=
	rs=
	fga=
	if [ ! -v $( command -v tput ) ]; then
		fg=$( tput setaf 6 )
		fga=$( tput setaf 3 )
		rs=$( tput sgr0 )
	fi
	
	if [ "$1" == "-h" ] || [ "$1" == "--h" ] || [ "$1" == "-help" ] || \
	[ "$1" == "--help" ]
	then
		# preprocess help output 
		arguments=$( grep -o '[[0-9]]' <<< "$function_help" | wc -l )
		function_help=$( echo -e "$function_help" | \
		sed -e "s/\[1\]/\n[1]/g" )
		function_help=$( echo -e "$function_help" | \
		sed -r -e "s/(\[[0-9]\])/\n${fga}\1${rs}/g" )
		# construct help output 
		help_string="\nUsage: ${fg}${function_name}${rs}"
		arg_string=
		for i in $( seq 1 $arguments ); do arg_string="$arg_string[$i] "; done
		help_string="${help_string} ${fga}${arg_string}${rs}\n\n${function_help}"
		# print help string 
		bbc_justify_text "$help_string" 70
        return 1
    else
        return 0
	fi
}

function init_manual () {
	for fct in $( cat $( bbc_whereami ) | grep -e "^function bbc_.*" | \
	sed -e "s/^function[ ]*//g" -e "s/ (.*//g" )
	do
		eval $fct -h 
		printf '\n'; printf '_%.0s' {1..70}; printf '\n'
	done
}

# if called directly, print all help sections 
if [[ $_ == $0 ]]
then
	init_manual
fi
