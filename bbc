#!/bin/bash
# ==============================================================================
# BASTI'S BASH COMMONS
# Commonly used bash methods.
# 
# Best way to include is to add the script to your path and include with
# if [ ! -v $( command -v "bbc" ) ]; then source bbc; else exit; fi
#
# Licensed under the Apache License, Version 2.0 (the "License");
# ==============================================================================

function bbc_get_bash_version () {
	# Returns the bash version as separated string to check for compatibility

	bash --version | head -n1 | sed -r -e "s/^[^0-9]+([0-9\\.]+).*/\1/g" |\
	tr "." " "
}

function bbc_log () {
	# A message logger that highlights or hides the given text according to
	# the script-wide logging configuration
	# $1 = Message to be displayed
	# $2 = Log level (not implemented yet)

	bbc_exe tput setaf 2
	echo $@
	bbc_exe tput sgr 0
}

function bbc_askpass () {
	# Asks the user for a password
	# $1 = Optional alternate question, e.g. "Enter your google.com password"

	question="Enter password"
	if [ $# -ge 1 ]; then question=$1; fi
	read -s -p "$question: " bbc_password
	echo ""
}

function bbc_yesno () {
	# Asks the user a yes/no question and returns 1 if 'yes' and 0 if 'no'
	# $1 = The question to ask

	read -p "$1 (y/n)" -n 1 -r
	echo "" # (optional) move to a new line
	if [[ $REPLY =~ ^[Yy]$ ]]
	then
		echo 1
	else
		echo 0
	fi
}

function bbc_urlescape () {
	# URL-escapes the given string
	# $1 = The string to be escaped.

	echo "$1" | sed -e "s/!/%21/g" -e "s/\"/%22/g" -e "s/#/%23/g" -e "s/\\$/%24/g" \
	-e "s/&/%26/g" -e "s/'/%27/g" -e "s/(/%28/g" -e "s/)/%29/g" \
	-e "s/*/%2A/g" -e "s/+/%2B/g" -e "s/,/%2C/g" -e "s/\//%2F/g" -e "s/:/%3A/g" \
	-e "s/;/%3B/g" -e "s/=/%3D/g" -e "s/?/%3F/g" -e "s/@/%40/g" -e "s/\[/%5B/g" \
	-e "s/\]/%5D/g"

}

function bbc_exe () {
	# Tests if a command does exist and, if yes, runs it. This comes in handy
	# if you are unsure whether a tool exists.
	# $1 = Command to be executed

	if [ ! -v $( command -v $1 ) ]
	then
		eval $@
	fi
}

function bbc_print_xml () {
	# Pretty-prints an XML string to the command line.
	# $1 = XML file

	bbc_exe tput setaf 2
	echo
	xmllint --format $1
	echo
	bbc_exe tput sgr 0
}

function bbc_run_psql () {
	bbc_init_help "$FUNCNAME" 1 "Runs a given postgresql command through the \
psql command line. ATTENTION: This method assumes that \$PG_PASS \$PG_USSER \
and \$PG_DB are set somewhere in your script.\n[1] PostgreSQL Query with \
escaped quotation marks." $@ || return $?

	export PGPASSWORD=$PG_PASS
	psql -h localhost -t -F " " -A -c "$1" $PG_DB $PG_USER
}

function bbc_get_datetime () {
	bbc_init_help "$FUNCNAME" 0 "Returns a file-safe datetime timestamp to \
be used in files." $@ || return $?
	
	date "+%Y%m%d-%H%M%S"
}

function bbc_whereami () {
	bbc_init_help "$FUNCNAME" 0 "Returns the location of the current script."\
	$@ || return $?

	location=$( readlink -f $( dirname $0 ))
	echo ${location}/$( basename $0 )
}

function bbc_get_filename () {
	bbc_init_help "$FUNCNAME" 1 "Returns filename without path and suffix \
from given filepath.\n[1] Path to file." $@ || return $?
	
	filename=$(basename "$1")
	echo ${filename%.*}
}

function bbc_get_filesuffix () {
	bbc_init_help "$FUNCNAME" 1 "Returns the file suffix without path and \
filename from given filepath.\n[1] Path to file." $@ || return $?
	
	filename=$(basename "$1")
	echo ${filename##*.}
}

function bbc_split_on_pattern () {
	bbc_init_help "$FUNCNAME" 2 "Splits a file on a given regex pattern into \
multiple files.\n[1] Input file.\n[2] Regular expression to split file at." \
$@ || return $?
	
	base=$( bbc_get_filename $1 )
	suff=$( bbc_get_filesuffix $1 )
	awk -v pat="$2" -v base=$base -v suff=$suff '$0 ~ pat { i++ }{ \
	print > base"."sprintf("%05d", i)"."suff }' ${1}
}

################################################################################

function bbc_init_help () {
	function_name="$1"; shift
	arguments=$1; shift
	function_help="$1"; shift
	if [ "$1" == "-h" ] || [ "$1" == "--h" ] || [ "$1" == "-help" ] || \
	[ "$1" == "--help" ]
	then 
		printf "\nUsage: ${function_name} "
		for i in $( seq 1 $arguments ); do printf "[$i] "; done
		printf "\n\n"
		echo -e "${function_help}\n"
		return 1
	else
		return 0
	fi
}
