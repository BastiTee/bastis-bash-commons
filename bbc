#!/bin/bash
# ==============================================================================
# BASTI'S BASH COMMONS
# Commonly used bash methods.
# 
# Best way to include is to add the script to your path and include with
# if [ ! -v $( command -v "bbc" ) ]; then source bbc; else exit; fi
#
# Licensed under the Apache License, Version 2.0 (the "License");
# ==============================================================================

# Make sure that commons only get sourced once 
if [[ $_ != $0 ]] && [ ! -v $BBC_COMMONS_SOURCED ] && \
[ $BBC_COMMONS_SOURCED == 1 ]
then
	return 0
fi

function bbc_remove_duplicate_empty_lines () {
	init_help_output "$FUNCNAME" "Removes duplicate empty lines read from \
standard-in." $@ || return $?
	
	sed 'N;/^\n$/d;P;D' < /dev/stdin 
}

function bbc_wd () {
	init_help_output "$FUNCNAME" "An extension of the system's default cd \
command with pattern-based searching of candidates before changing to the \
candidate folder that has been found. wd means 'warp directory'.[1] Directory \
pattern." $@ || return $?

	MAX_DEPTH=3 # How deep should wd look in the folder tree for matches? 
	MAX_HITS_BEFORE_BREAK=5 # After how many hits should wd stop searching? 
	
	# on 'wd' without any options, don't do anything (in contrast to 'cd' )
	if [ $# -le 0 ] || [ -v $1 ]; then return; fi 
	# keep 'cd -' function, but without output
	if [ "$1" == "-" ]; then cd - &> /dev/null; return; fi 
	# keep 'cd ..' function
	if [ "$1" == ".." ]; then cd ..; return; fi  
	# 'cd ...' function
	if [ "$1" == "..." ]; then cd ..; cd ..; return; fi
	# 'cd <folder>' if folder exists (basic cd behaviour) 
	if [ -e $1 ] && [ -d $1 ]; then cd $1; return; fi 
	# break on absolute paths 
	if [[ "$1" =~ ^/.* ]]; then
		echo "-bash: wd: $1: Warp on absolute paths not supported"; return
	fi
	# pattern-based search and changing of dirs
	no_hits=0
	first_hit=
	pattern=$( echo "*${1}*" | sed -r -e "s/[\/]+/\//g" -e "s/\//*\/*/g" )
	command="find -maxdepth $MAX_DEPTH -type d -iwholename \"$pattern\" \
-prune 2>/dev/null"
	# echo "--- warping to: '${pattern}' with '${command}'"
	for hit in $( eval $command ) 
	do
		if [ $no_hits == 0 ]; then first_hit=$hit; fi 
		no_hits=$(( $no_hits + 1 ))
		echo $hit
		if [ $no_hits == $MAX_HITS_BEFORE_BREAK ]; then 
			echo -e "...\n-bash: wd: $1: Too many potential hits"; break 
		fi 
	done
	if [ $no_hits == 0 ]; then 
		echo "-bash: wd: $1: No such file or directory"; return
	elif [ $no_hits -ge 2 ]; then 
		return
	else 
		cd $first_hit
	fi 
}

function bbc_get_bash_version () {
	init_help_output "$FUNCNAME" "Returns the bash version as separated string \
to check for compatibility." $@ || return $?

	bash --version | head -n1 | sed -r -e "s/^[^0-9]+([0-9\\.]+).*/\1/g" |\
	tr "." " "
}

function bbc_askpass () {
	init_help_output "$FUNCNAME" "Asks the user for a password.[1] Optional \
alternate question, e.g. \"Enter your google.com password\"." $@ || return $?

	question="Enter password"
	if [ $# -ge 1 ]; then question=$1; fi
	read -s -p "$question: " bbc_password
	echo ""
}

function bbc_yesno () {
	init_help_output "$FUNCNAME" "Asks the user a yes/no question and returns \
1 if 'yes' and 0 if 'no'.[1] The question to ask." $@ || return $?

	read -p "$1 (y/n)" -n 1 -r
	echo "" # (optional) move to a new line
	if [[ $REPLY =~ ^[Yy]$ ]]
	then
		echo 1
	else
		echo 0
	fi
}

function bbc_urlencode () {
	init_help_output "$FUNCNAME" "URL-enodes the given string.[1] The \
string to be encoded." $@ || return $?

	echo "$1" | sed -e "s/!/%21/g" -e "s/\"/%22/g" -e "s/#/%23/g" \
	-e "s/\\$/%24/g" -e "s/&/%26/g" -e "s/'/%27/g" -e "s/(/%28/g" \
	-e "s/)/%29/g" -e "s/*/%2A/g" -e "s/+/%2B/g" -e "s/,/%2C/g" \
	-e "s/\//%2F/g" -e "s/:/%3A/g" -e "s/;/%3B/g" -e "s/=/%3D/g" \
	-e "s/?/%3F/g" -e "s/@/%40/g" -e "s/\[/%5B/g" -e "s/\]/%5D/g" \
	-e "s/ /%20/g" 
}

function bbc_exe () {
	init_help_output "$FUNCNAME" "Tests if a command does exist and, if yes, \
runs it. This comes in handy if you are unsure whether a tool exists.\
[1] Command to be executed." $@ || return $?
	
	if [ ! -v $( command -v $1 ) ]
	then
		eval $@
	fi
}

function bbc_print_xml () {
	init_help_output "$FUNCNAME" "Pretty-prints an XML string to the command \
line.[1] XML-file." $@ || return $?
	
	bbc_exe tput setaf 2
	echo
	xmllint --format $1
	echo
	bbc_exe tput sgr 0
}

function bbc_run_psql () {
	init_help_output "$FUNCNAME" "Runs a given postgresql command through the \
psql command line. ATTENTION: This method assumes that \$PG_PASS \$PG_USSER \
and \$PG_DB are set somewhere in your script.[1] PostgreSQL Query with \
escaped quotation marks." $@ || return $?

	export PGPASSWORD=$PG_PASS
	psql -h localhost -t -F " " -A -c "$1" $PG_DB $PG_USER
}

function bbc_get_datetime () {
	init_help_output "$FUNCNAME" "Returns a file-safe datetime timestamp to \
be used in files." $@ || return $?
	
	date "+%Y%m%d-%H%M%S"
}

function bbc_epoch () {
	init_help_output "$FUNCNAME" "Returns the current epoch timestamp." $@ || \
return $?
	
	date "+%s"
}

function bbc_whereami () {
	init_help_output "$FUNCNAME" "Returns the location of the current script.\
[1] If '-d' then return parent dirname only."\
	$@ || return $?

	location=$( readlink -f $( dirname $0 ))
	if [ "$1" == "-d" ]; then
		echo ${location}
	else
		echo ${location}/$( basename $0 )
	fi
}

function bbc_get_filename () {
	init_help_output "$FUNCNAME" "Returns filename without path and suffix \
from given filepath.[1] Path to file." $@ || return $?
	
	filename=$(basename "$1")
	echo ${filename%.*}
}

function bbc_get_filesuffix () {
	init_help_output "$FUNCNAME" "Returns the file suffix without path and \
filename from given filepath.[1] Path to file." $@ || return $?
	
	filename=$(basename "$1")
	echo ${filename##*.}
}

function bbc_split_on_pattern () {
	init_help_output "$FUNCNAME" "Splits a file on a given regex pattern into \
multiple files.[1] Input file.[2] Regular expression to split file at." \
$@ || return $?
	
	base=$( bbc_get_filename $1 )
	suff=$( bbc_get_filesuffix $1 )
	awk -v pat="$2" -v base=$base -v suff=$suff '$0 ~ pat { i++ }{ \
	print > base"."sprintf("%05d", i)"."suff }' ${1}
}

function bbc_justify_text () {
	init_help_output "$FUNCNAME" "Folds the given text to either at a fixed \
number of columns or, if obtainable, the width of the console or at a fixed \
with of 70.[1] Input text.[2] Optional line width." \
	$@ || return $?

	columns=$2
	if [ -v $columns ]; then columns=$( bbc_exe "tput cols" ); fi
	if [ -v $columns ]; then columns=70; fi
	echo -e "$1" | fold -s -w $columns 
}

# ==============================================================================
# INTERNAL FUNCTIONS
# ==============================================================================

function init_help_output () {
	function_name="$1"; shift
	function_help="$1"; shift
	
	if [ "$1" == "-h" ] || [ "$1" == "--h" ] || [ "$1" == "-help" ] || \
	[ "$1" == "--help" ]
	then
		# preprocess help output 
		arguments=$( grep -o '[[0-9]]' <<< "$function_help" | wc -l )
		function_help=$( echo -e "$function_help" | \
		sed -e "s/\[1\]/\n[1]/g" )
		function_help=$( echo -e "$function_help" | \
		sed -r -e "s/(\[[0-9]\])/\n\1/g" )
		# construct help output 
		help_string="\nUsage: ${function_name}"
		arg_string=
		for i in $( seq 1 $arguments ); do arg_string="$arg_string[$i] "; done
		help_string="${help_string} ${arg_string}\n\n${function_help}"
		# print help string 
		bbc_justify_text "$help_string" 70
		return 1
	else
		return 0
	fi
}

function init_manual () {
	for fct in $( cat $( bbc_whereami ) | grep -e "^function bbc_.*" | \
	sed -e "s/^function[ ]*//g" -e "s/ (.*//g" )
	do
		eval $fct -h 
		printf '\n'; printf '=%.0s' {1..70}; printf '\n'
	done
}

# if called directly, print all help sections 
if [[ $_ != $0 ]]
then
	export BBC_COMMONS_SOURCED=1 # publish that this was sourced already 
	return 0 
else
	init_manual
fi
